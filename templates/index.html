<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Censo Territorio - Visualizaci√≥n de Datos Censales</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }

        .sidebar {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            height: fit-content;
        }

        .map-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            height: 700px;
        }

        #map {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        .form-group input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #667eea;
            border-radius: 8px;
            background: #f8f9fa;
            cursor: pointer;
        }

        .form-group input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .form-group input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .stats-panel {
            margin-top: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
            display: none;
        }

        .stats-panel.show {
            display: block;
        }

        .stats-panel h3 {
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .stat-item {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .stat-label {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 20px;
            display: none;
            background: #f8f9fa;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #e0e0e0;
        }

        .loading.show {
            display: block;
        }

        .newtons-cradle {
            --uib-size: 50px;
            --uib-speed: 1.2s;
            --uib-color: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--uib-size);
            height: var(--uib-size);
            margin: 20px auto;
        }

        .newtons-cradle__dot {
            position: relative;
            display: flex;
            align-items: center;
            height: 100%;
            width: 25%;
            transform-origin: center top;
        }

        .newtons-cradle__dot::after {
            content: '';
            display: block;
            width: 100%;
            height: 25%;
            border-radius: 50%;
            background-color: var(--uib-color);
        }

        .newtons-cradle__dot:first-child {
            animation: swing var(--uib-speed) linear infinite;
        }

        .newtons-cradle__dot:last-child {
            animation: swing2 var(--uib-speed) linear infinite;
        }

        .newtons-cradle__dot:nth-child(2)::after {
            background-color: #6d74dc;
        }

        .newtons-cradle__dot:nth-child(3)::after {
            background-color: #725bb7;
        }

        .newtons-cradle__dot:last-child::after {
            background-color: #764ba2;
        }

        @keyframes swing {
            0% {
                transform: rotate(0deg);
                animation-timing-function: ease-out;
            }

            25% {
                transform: rotate(70deg);
                animation-timing-function: ease-in;
            }

            50% {
                transform: rotate(0deg);
                animation-timing-function: linear;
            }
        }

        @keyframes swing2 {
            0% {
                transform: rotate(0deg);
                animation-timing-function: linear;
            }

            50% {
                transform: rotate(0deg);
                animation-timing-function: ease-out;
            }

            75% {
                transform: rotate(-70deg);
                animation-timing-function: ease-in;
            }

            100% {
                transform: rotate(0deg);
                animation-timing-function: linear;
            }
        }

        .info-panel {
            margin-top: 15px;
            position: relative;
        }

        .info-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            background: #f0f2ff;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .info-toggle:hover {
            background: #e0e4ff;
        }

        .info-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid #e0e0e0;
            margin-top: 5px;
        }

        .info-panel:hover .info-content,
        .info-panel:focus-within .info-content {
            display: block;
        }

        .legend {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è Censo Territorio</h1>
            <p>Visualizaci√≥n de Datos Censales de Barcelona</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <form id="upload-form">
                    <div class="form-group">
                        <label for="kml-file">Subir archivo KML:</label>
                        <input type="file" id="kml-file" name="kml_file" accept=".kml" required>
                    </div>


                    <button type="submit" class="btn" id="calculate-btn">Calcular Poblaci√≥n</button>
                </form>

                <div style="margin-top: 15px;">
                    <button type="button" class="btn" id="reset-view-btn"
                        style="background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">
                        Mostrar Todas las Zonas
                    </button>
                </div>

                <div class="loading" id="loading">
                    <div class="newtons-cradle">
                        <div class="newtons-cradle__dot"></div>
                        <div class="newtons-cradle__dot"></div>
                        <div class="newtons-cradle__dot"></div>
                        <div class="newtons-cradle__dot"></div>
                    </div>
                    <p style="color: #666; font-weight: 600; font-size: 0.9em;">Calculando poblaci√≥n...</p>
                </div>

                <div class="stats-panel" id="stats-panel">
                    <h3>üìä Resultados</h3>
                    <div class="stat-item">
                        <div class="stat-label">Poblaci√≥n Total</div>
                        <div class="stat-value" id="total-population">-</div>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="info-toggle">
                        <span>‚ÑπÔ∏è Instrucciones</span>
                    </div>
                    <div class="info-content">
                        <ul style="padding-left: 20px; color: #666; font-size: 0.9em;">
                            <li style="margin-bottom: 8px;">Sube un archivo KML con tu zona de inter√©s</li>
                            <li style="margin-bottom: 8px;">El mapa muestra todas las zonas censales</li>
                            <li style="margin-bottom: 8px;">Haz clic en una zona para ver detalles</li>
                            <li>Los colores indican la densidad (hab/km¬≤)</li>
                        </ul>
                    </div>
                </div>

                <div class="legend" id="density-legend">
                    <h4>Leyenda - Densidad</h4>
                    <div id="legend-content">
                        <p style="font-size: 0.9em; color: #666; font-style: italic;">Cargando...</p>
                    </div>
                </div>
            </div>

            <div class="map-container">
                <div id="map"></div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Main Script -->
    <script>
        // Initialize map centered on Barcelona
        const map = L.map('map').setView([41.3851, 2.1734], 12);

        // Create custom panes for layer ordering
        if (!map.getPane('kmlPane')) {
            map.createPane('kmlPane');
            map.getPane('kmlPane').style.zIndex = 400; // Behind overlay panes
        }
        if (!map.getPane('censusPane')) {
            map.createPane('censusPane');
            map.getPane('censusPane').style.zIndex = 500; // Above KML pane
        }

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        let censusZonesLayer = null;
        let uploadedZoneLayer = null;
        let densityMax = 0;
        let densityMin = Infinity;

        // Function to get color based on density ratio (7-step gradation)
        function getDensityColor(ratio) {
            // 7-step color scale: green -> light green -> yellow-green -> yellow -> orange -> red-orange -> red
            if (ratio < 0.14) {
                return '#006837'; // Dark green
            } else if (ratio < 0.28) {
                return '#238b45'; // Medium green
            } else if (ratio < 0.43) {
                return '#74c476'; // Light green
            } else if (ratio < 0.57) {
                return '#fed976'; // Yellow
            } else if (ratio < 0.71) {
                return '#fd8d3c'; // Orange
            } else if (ratio < 0.86) {
                return '#e31a1c'; // Red-orange
            } else {
                return '#99000d'; // Dark red
            }
        }

        // Global variable to store visible densities for legend calculation
        let visibleDensities = new Set();

        // Function to update dynamic legend
        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            if (densityMax === 0 || densityMin === Infinity) {
                legendContent.innerHTML = '<p style="font-size: 0.9em; color: #666; font-style: italic;">Cargando...</p>';
                return;
            }

            // Collect unique density values and count them
            const uniqueDensities = Array.from(visibleDensities).sort((a, b) => a - b);
            const numUnique = uniqueDensities.length;

            // Calculate steps (between 1 and 7)
            let steps = Math.min(numUnique, 7);
            if (steps === 0) steps = 1;

            let legendHTML = '<div style="margin-bottom: 8px;">';

            if (densityMax === densityMin || steps === 1) {
                // Special case: Only one value or all values are the same
                const color = getDensityColor(0.5); // Use a neutral color from the scale
                legendHTML += `
                    <div class="legend-item" style="margin-bottom: 6px;">
                        <div class="legend-color" style="background: ${color};"></div>
                        <span style="font-size: 0.85em;">${Math.round(densityMax).toLocaleString()} hab/km¬≤</span>
                    </div>
                `;
            } else {
                const stepSize = (densityMax - densityMin) / steps;

                // Generate legend items for each color step
                for (let i = 0; i < steps; i++) {
                    const ratio = i / (steps - 1);
                    const color = getDensityColor(ratio);
                    const minD = densityMin + (stepSize * i);
                    const maxD = i === steps - 1 ? densityMax : densityMin + (stepSize * (i + 1));

                    legendHTML += `
                        <div class="legend-item" style="margin-bottom: 6px;">
                            <div class="legend-color" style="background: ${color};"></div>
                            <span style="font-size: 0.85em;">${Math.round(minD).toLocaleString()} - ${Math.round(maxD).toLocaleString()} hab/km¬≤</span>
                        </div>
                    `;
                }
            }

            legendHTML += '</div>';
            legendHTML += '<p style="margin-top: 10px; font-size: 0.85em; color: #666;">Basado en densidad poblacional</p>';
            legendContent.innerHTML = legendHTML;
        }

        // Load census zones on page load
        async function loadCensusZones() {
            try {
                // Load all census zones
                const response = await fetch('/api/census-zones');
                const geojson = await response.json();

                // Calculate min/max density and unique values for color scaling
                visibleDensities.clear();
                geojson.features.forEach(feature => {
                    const density = feature.properties.density || 0;
                    if (density > 0) {
                        visibleDensities.add(density);
                        if (density > densityMax) densityMax = density;
                        if (density < densityMin) densityMin = density;
                    }
                });

                // Update dynamic legend
                updateLegend();

                // Add zones to map with color coding based on density
                censusZonesLayer = L.geoJSON(geojson, {
                    pane: 'censusPane',
                    style: function (feature) {
                        const density = feature.properties.density || 0;
                        const ratio = densityMax > densityMin ? (density - densityMin) / (densityMax - densityMin) : 0.5;
                        const color = getDensityColor(ratio);

                        return {
                            color: '#333',
                            weight: 1,
                            fillColor: color,
                            fillOpacity: 0.6
                        };
                    },
                    onEachFeature: function (feature, layer) {
                        const props = feature.properties;
                        const density = props.density || 0;
                        const area = props.area_km2 || 0;
                        layer.bindPopup(`
                            <strong>${props.district}</strong><br>
                            ${props.neighborhood}<br>
                            Secci√≥n: ${props.district_code}${props.section_code}<br>
                            Poblaci√≥n: <strong>${props.population.toLocaleString()}</strong><br>
                            √Årea: ${area.toFixed(2)} km¬≤<br>
                            Densidad: <strong>${density.toLocaleString()} hab/km¬≤</strong>
                        `);

                        layer.on('click', function () {
                            layer.setStyle({ weight: 3, color: '#0066cc' });
                            setTimeout(() => {
                                layer.setStyle({ weight: 1, color: '#333' });
                            }, 2000);
                        });
                    }
                }).addTo(map);
            } catch (error) {
                console.error('Error loading census zones:', error);
                alert('Error al cargar las zonas censales');
            }
        }

        // Handle form submission
        document.getElementById('upload-form').addEventListener('submit', async function (e) {
            e.preventDefault();

            const formData = new FormData(this);
            const fileInput = document.getElementById('kml-file');

            if (!fileInput.files[0]) {
                alert('Por favor selecciona un archivo KML');
                return;
            }

            const loading = document.getElementById('loading');
            const statsPanel = document.getElementById('stats-panel');
            const calculateBtn = document.getElementById('calculate-btn');

            loading.classList.add('show');
            statsPanel.classList.remove('show');
            calculateBtn.disabled = true;

            try {
                const response = await fetch('/api/calculate-population', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    // Display statistics
                    document.getElementById('total-population').textContent =
                        data.population.toLocaleString();

                    statsPanel.classList.add('show');

                    // Add uploaded zone to map (transparent, only border, behind census zones)
                    if (uploadedZoneLayer) {
                        map.removeLayer(uploadedZoneLayer);
                    }

                    uploadedZoneLayer = L.geoJSON(data.geojson, {
                        pane: 'kmlPane',
                        style: {
                            color: '#ff0000',
                            weight: 6,
                            dashArray: '10, 10',
                            fillColor: '#ff0000',
                            fillOpacity: 0.1,
                            opacity: 1
                        }
                    }).addTo(map);

                    // Filter census zones to only show intersecting ones
                    if (censusZonesLayer) {
                        // Get intersecting zone codes from statistics (these are calculated using proper polygon intersection)
                        const intersectingCodes = new Set();
                        if (data.statistics && data.statistics.intersecting_zones) {
                            data.statistics.intersecting_zones.forEach(zone => {
                                const code = `${zone.district_code.toString().padStart(2, '0')}${zone.section_code.toString().padStart(3, '0')}`;
                                intersectingCodes.add(parseInt(code));
                            });
                        }

                        // Collect visible zones to recalculate density range
                        const visibleZones = [];
                        visibleDensities.clear();

                        // Filter zones: hide non-intersecting ones (ONLY use zone codes from backend, no bbox fallback)
                        censusZonesLayer.eachLayer(function (layer) {
                            if (layer.feature && layer.feature.properties) {
                                const props = layer.feature.properties;

                                // Create zone code like backend does
                                const zoneCode = parseInt(`${props.district_code.toString().padStart(2, '0')}${props.section_code.toString().padStart(3, '0')}`);

                                // Check if zone intersects - ONLY use codes from backend statistics (proper polygon intersection)
                                const intersects = intersectingCodes.has(zoneCode);

                                if (!intersects) {
                                    // Hide non-intersecting zones
                                    layer.setStyle({ fillOpacity: 0, opacity: 0 });
                                } else {
                                    // Collect for density recalculation
                                    visibleZones.push(props);
                                    if (props.density > 0) visibleDensities.add(props.density);
                                }
                            }
                        });

                        // Recalculate density min/max based only on visible zones
                        let newDensityMax = 0;
                        let newDensityMin = Infinity;
                        visibleZones.forEach(props => {
                            const density = props.density || 0;
                            if (density > 0) {
                                if (density > newDensityMax) newDensityMax = density;
                                if (density < newDensityMin) newDensityMin = density;
                            }
                        });

                        // Update global density range
                        if (newDensityMax > 0 && newDensityMin < Infinity) {
                            densityMax = newDensityMax;
                            densityMin = newDensityMin;
                        }

                        // Update colors for visible zones with new density range
                        censusZonesLayer.eachLayer(function (layer) {
                            if (layer.feature && layer.feature.properties) {
                                const props = layer.feature.properties;
                                const zoneCode = parseInt(`${props.district_code.toString().padStart(2, '0')}${props.section_code.toString().padStart(3, '0')}`);
                                const intersects = intersectingCodes.has(zoneCode);

                                if (intersects) {
                                    // Update color with new density range
                                    const density = props.density || 0;
                                    const ratio = densityMax > densityMin ? (density - densityMin) / (densityMax - densityMin) : 0.5;
                                    const color = getDensityColor(ratio);
                                    layer.setStyle({
                                        fillColor: color,
                                        fillOpacity: 0.6,
                                        opacity: 1,
                                        weight: 1,
                                        color: '#333'
                                    });
                                }
                            }
                        });

                        // Update legend with new density range
                        updateLegend();

                        // Ensure census zones are on top
                        censusZonesLayer.bringToFront();
                    }

                    // Zoom to uploaded polygon with padding
                    map.fitBounds(uploadedZoneLayer.getBounds(), { padding: [50, 50] });
                } else {
                    alert('Error: ' + (data.error || 'Error desconocido'));
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error al procesar el archivo KML');
            } finally {
                setTimeout(() => {
                    loading.classList.remove('show');
                }, 500);
                calculateBtn.disabled = false;
            }
        });

        // Function to reset view - show all zones
        function resetView() {
            if (censusZonesLayer) {
                censusZonesLayer.eachLayer(function (layer) {
                    if (layer.feature && layer.feature.properties) {
                        const density = layer.feature.properties.density || 0;
                        const ratio = densityMax > densityMin ? (density - densityMin) / (densityMax - densityMin) : 0;
                        const color = getDensityColor(ratio);
                        layer.setStyle({
                            fillColor: color,
                            fillOpacity: 0.6,
                            opacity: 1,
                            weight: 1,
                            color: '#333'
                        });
                    }
                });
            }
            if (censusZonesLayer) {
                map.fitBounds(censusZonesLayer.getBounds());
            }
        }

        // Reset view button
        document.getElementById('reset-view-btn').addEventListener('click', resetView);

        // Load census zones on page load
        loadCensusZones();
    </script>
</body>

</html>